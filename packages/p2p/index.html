<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>JS-Waku Chat</title>
</head>

<body>
<div><h1>Waku Node Status</h1></div>
<div id="status"></div>

<label for="textInput">Message text</label>
<input
        disabled
        id="textInput"
        placeholder="Type your message here"
        type="text"
/>
<button disabled id="sendButton" type="button">
    Send Message using Relay
</button>

<div><h1>Messages</h1></div>
<div id="messages"></div>

<script type="module">
  /**
   * Demonstrate usage of js-waku in the browser. Use relay, gossip sub protocol to send and receive messages.
   * Recommended payload is protobuf. Using simple utf-8 string for demo purposes only.
   */

  // noinspection JSFileReferences
  import {
    waitForRemotePeer,
    createDecoder,
    createEncoder,
    createRelayNode,
  } from "https://unpkg.com/@waku/sdk@0.0.18/bundle/index.js";

  import "https://cdn.jsdelivr.net/npm/protobufjs@latest/dist/protobuf.min.js";

  const statusDiv = document.getElementById("status");
  const messagesDiv = document.getElementById("messages");
  const textInput = document.getElementById("textInput");
  const sendButton = document.getElementById("sendButton");

  // ===============================================================================================

  const systemTopic = "/vapor/1/system/proto"

  // NOTE: Do we need `ephemeral = true`? (default is `false`).
  // Probably not because we're not running a storage node.
  // If we want to support offline messaging, then we can use a storage nodes.
  const systemEncoder = createEncoder({ contentTopic: systemTopic })
  const systemDecoder = createDecoder(systemTopic)

  // const SystemMessage = new protobuf.Type("SystemMessage")
  //   .add(new protobuf.Field("timestamp", 1, "uint64"))
  //   .add(new protobuf.Field("sender", 2, "string"))
  //   .add(new protobuf.Field("type", 3, "uint32"))
  //   .add(new protobuf.Field("args", 4, "bytes"))
  //   .add(new protobuf.Field("signature", 5, "bytes"))

  const SystemMessage = new protobuf.Type("SystemMessage")
    .add(new protobuf.Field("string", 1, "string"))

  export async function subscribeToSystem(node, msgCallback) {
    return subscribeToTopic(node, systemDecoder, (payload) => {
      msgCallback(SystemMessage.decode(payload))
    })
  }

  export async function sendSystemMessage(node, payload) {
    await sendMessage(node, systemEncoder, SystemMessage, payload)
  }

  // =================================================================================================

  /**
   * Starts and return a waku node. Relay node for now.
   */
  export async function startWakuNode() {
    const node = await createRelayNode({
      // Emits messages to self too.
      emitSelf: true,
      // Plot twist: default bootstrap is not actually the default...
      defaultBootstrap: true,
    })

    // // In case we want to run a light node instead.
    // const node = await createLightNode()
    // try {
    //   // TODO lookup docs of this
    //   await getPeers()
    // } catch (e) {
    //   signalStatus("Failed to find a peer")
    // }

    await node.start()

    // For debugging
    window.waku = node

    return node
  }

  // =================================================================================================

  /**
   * Subscribe the node to the given topic, calling `msgCallback` with the message payload if it
   * exists. Returns an unsubscribe function.
   */
  export async function subscribeToTopic(node, decoder, payloadCallback) {
    return node.relay.subscribe(decoder, (message) => {
      // Checks there is a payload on the message.
      // Waku Message is encoded in protobuf, in proto v3 fields are always optional.
      if (!message.payload) return
      payloadCallback(message.payload)
    })
  }

  // =================================================================================================

  /**
   * Example function for the waku setup that subscribes to the system topic.
   */
  export async function setupWaku(signalStatus, msgCallback) {
    const node = await startWakuNode()
    await subscribeToSystem(node, msgCallback)
    signalStatus("Connecting to a peer")

    // Best effort method that waits for the Waku node to be connected to remote
    // waku nodes (peers) and for appropriate handshakes to be done.
    await waitForRemotePeer(node)

    // // For light node
    // await waitForRemotePeer(node, [
    //   Protocols.LightPush,
    //   Protocols.Filter,
    // ])

    return node
  }

  // =================================================================================================

  // // Example
  // const msgType = ChatMessage
  // const msgPayload = {
  //   timestamp: Date.now(),
  //   sender: "Alice",
  //   message: "Hello, World!",
  // }

  export async function sendMessage(node, encoder, msgType, msgPayload) {
    const protoMessage = msgType.create(msgPayload)
    const serialisedMessage = msgType.encode(protoMessage).finish()
    await node.relay.send(encoder, { payload: serialisedMessage })
  }

  // =================================================================================================

  try {
    const signalStatus = (status) => {
      statusDiv.innerHTML = `<p>${status}</p>`;
    }

    signalStatus("Starting")

    const waku = await setupWaku(signalStatus, (message) => {
      messagesDiv.innerHTML = `<p>${message.string}</p><br />` + messagesDiv.innerHTML
    })

    // We are now connected to a remote peer, let's define the `sendMessage`
    // function that sends the text input over Waku Relay, the gossipsub
    // protocol.
    sendButton.onclick = async () => {
      await sendSystemMessage(waku, { string: textInput.value })
      console.log("Message sent!")

      // Reset the text input.
      textInput.value = null
    };

    // Ready to send & receive messages, enable text input.
    textInput.disabled = false;
    sendButton.disabled = false;
    statusDiv.innerHTML = "<p>Ready!</p>";
  } catch (e) {
    statusDiv.innerHTML = "Failed to start application";
    console.log(e);
  }
</script>
</body>
</html>
